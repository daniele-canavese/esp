# Reports

This folder contains the original ADSS reports that we generated for the three ASPIRE use cases:

| file                  | preview                                                                                                                 | description                                                                                                  |
|-----------------------|-------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------|
| `DemoPlayer.html`     | [click](https://htmlpreview.github.io/?https://github.com/daniele-canavese/esp/blob/master/reports/DemoPlayer.html)     | report of a video streaming library for the Nagra Kudelski Group (https://www.nagra.com/)                    |
| `LicenseManager.html` | [click](https://htmlpreview.github.io/?https://github.com/daniele-canavese/esp/blob/master/reports/LicenseManager.html) | report of a license managing library for the SafeNet Inc., now Thales roup (https://www.thalesgroup.com/)    |
| `OTP.html`            | [click](https://htmlpreview.github.io/?https://github.com/daniele-canavese/esp/blob/master/reports/OTP.html)            | report of a one time password application for Gemalto N. V., now Thales Group (https://www.thalesgroup.com/) |

## Protections

The reports were generated by using the following protection techniques:

- *anti-debugging*, which makes an application self-debugging thus restraining the attackers from attaching their own
  debugger;
- *binary obfuscations - branch functions*, which harden the understanding of an application control flow by
  substituting unconditional branches with calls to custom-made branching functions;
- *binary obfuscations - function flattening*, which replaces the application control flow with a single loop
  containing multiple branches;
- *binary obfuscations - opaque predicates*, which obfuscate the code by inserting fake conditional branches;
- *call stack checks*, which inserts integrity checks for ensuring that the stack has not been tampered;
- *code mobility*, which limits the reverse engineering of a code area by moving it to a trusted server, and downloading
  it at runtime when needed;
- *soft VM*, where a code area is translated into custom bytecode executed by a trusted virtual
  machine;
- *static remote attestation*which verifies application integrity at runtime by periodical transmitting integrity
  proofs (i.e. hashes of the memory) to a trusted server;
- *white box cryptography*, which merges the cryptographic keys into an obfuscated encryption algorithm.

## Solutions

Although the algorithms that we implemented do not fall in the explainable AI category, we have experimentally proven
their validity. In the next sections a simple description of their workings is introduced.

### Level 1 algorithm

The level 1 protection solutions are produced using a game theory based approach similar to a turn-based game like
chess. In this context, we have two players: the defender and the attacker. The defender plays only the first turn where
he deploys the protections and its goal is to select the most secure solution. The attacker plays all the other
remaining turns and his goal is to breach the security properties of as many assets as possible. This approach simulates
the release of a protected application in the world, where it is then subject to multiple attack attempts.

In order to find the best solution possible, the algorithm takes into account several factors such as:

- how protections impact various complexity and security metrics;
- what attacks are hindered by a specific protection;
- synergies and precedences between multiple stacked protections;
- the attacker expertise level;
- various constraints such as overhead limits.

### Level 2 algorithm

The level 2 solutions adds some additional protected areas to the level 1 protections as decoys to slow down an
attacker. The level 2 protection solutions are generated by solving a MILP (Mixed-Integer Linear Problem). Our model
takes into account various characteristics, such as client and server overhead constraints and respecting the order of
the protections.

In particular, uses two techniques to produce the additional decoy protected regions:

- *protection enlargement*: it makes an already protected code region bigger;
- *protection replication*: it adds a randomly protected code region by reusing a protection already present in the
  level 1 solution.

## Attack steps

In this context, an attack or attack path, is an ordered collection of simpler tasks known as *attack step*s. Our model
supports the following attack step types:

- `dynamicallyLocate`, the attacker must locate dynamically an application part in the binary (e.g. by debugging
  a process);
- `dynamicallyChange`, the attacker must change the code of the application part while it is running (e.g. by using a
  debugger);
- `executeCode`, the attacker must run a code region;
- `injectCode`, the attacker must dynamically inject some extra code in a code region while it is running;
- `readDatumAfterInitializazionAndDecryption`, the attacker must read from the memory some data after that has been
  decrypted (e.g. by using a debugger);
- `setup`, the attacker must prepare some server (usually to steal some data);
- `staticallyChange`, the attacker must change the code of an application part stored in a file (e.g. by using an
  hex-editor/assembler);
- `staticallyLocate`, the attacker must locate statically an application part in the binary (e.g. by
  disassembling a file).

## Use cases

During the ASPIRE project, All the three use cases' owner tested the results of the ADSS.

The level 1 protections as well as the level 2 protections were rated as correct, free from evident
incompatibilities or other issues that could lead applicability problems, very meaningful and effective to mitigate the
risks against the assets.

Unfortunately, experts were not able to state anything about the optimality of the golden combinations and their L2P
extensions.

### Demo player use case

This is the report of a video streaming library for the Nagra Kudelski Group (https://www.nagra.com/). You can read it
by clicking
[here](https://htmlpreview.github.io/?https://github.com/daniele-canavese/esp/blob/master/reports/DemoPlayer.html).

Some statistics about the assets:

| statistic               | value |
|-------------------------|-------|
| assets to protect       | 31    |
| code regions to protect | 28    |
| variables to protect    | 3     |
| SLOC to protect         | 1362  |

Some statistics about the attack paths:

| statistic                                               | value |
|---------------------------------------------------------|-------|
| attack paths                                            | 113   |
| attack paths that can be mitigated with high efficacy   | 81    |
| attack paths that can be mitigated with medium efficacy | 31    |
| attack paths that can be mitigated with low efficacy    | 0     |
| attack paths that cannot be mitigated                   | 1     |

Some statistics about the level 1 golden solution:

| protection                                                 | protected assets | protected SLOC |
|------------------------------------------------------------|------------------|----------------|
| anti-debugging                                             | 15               | 628            |
| binary obfuscation - branch functions (high overhead)      | 2                | 36             |
| binary obfuscation - branch functions (low overhead)       | 1                | 39             |
| binary obfuscation - branch functions (medium overhead)    | 1                | 39             |
| binary obfuscation - function flattening (high overhead)   | 2                | 177            |
| binary obfuscation - function flattening (low overhead)    | 1                | 23             |
| binary obfuscation - function flattening (medium overhead) | 1                | 52             |
| binary obfuscation - opaque predicates (high overhead)     | 1                | 33             |
| binary obfuscation - opaque predicates (medium overhead)   | 3                | 119            |
| binary obfuscation - opaque predicates (low overhead)      | 1                | 18             |
| soft VM                                                    | 14               | 724            |
| static remote attestation (low frequency)                  | 2                | 53             |
| static remote attestation (medium frequency)               | 1                | 5              |
| white box cryptography                                     | 9                | 15             |

Some statistics about the level 2 golden solution:

| protection                                                 | protected assets | protected SLOC |
|------------------------------------------------------------|------------------|----------------|
| anti-debugging                                             | 34               | 1243           |
| binary obfuscation - branch functions (high overhead)      | 2                | 36             |
| binary obfuscation - branch functions (low overhead)       | 7                | 323            |
| binary obfuscation - branch functions (medium overhead)    | 1                | 39             |
| binary obfuscation - function flattening (high overhead)   | 2                | 105            |
| binary obfuscation - function flattening (low overhead)    | 6                | 159            |
| binary obfuscation - function flattening (medium overhead) | 1                | 52             |
| binary obfuscation - opaque predicates (high overhead)     | 1                | 33             |
| binary obfuscation - opaque predicates (medium overhead)   | 3                | 119            |
| binary obfuscation - opaque predicates (low overhead)      | 5                | 39             |
| soft VM                                                    | 64               | 1963           |
| static remote attestation (low frequency)                  | 4                | 106            |
| static remote attestation (medium frequency)               | 2                | 10             |
| white box cryptography                                     | 9                | 15             |

The Nagra Kudelski Group experts validated our results and reported that:

- the attack path discovery is very useful and, to the best of the team's checks, the output exhaustive;
- by protecting against the high-level ADSS attack paths, most of the attack vectors are mitigated;
- the level 1 and 2 solutions are useful and, to the best of the team's checks, correct;
- the experts did not report nor had the time to check if better combinations were possible, to prove or confute
  their optimality.

### License manager use case

This is a report of a license managing library for the SafeNet Inc., now Thales roup (https://www.thalesgroup.com/). You
can read it by clicking
[here](https://htmlpreview.github.io/?https://github.com/daniele-canavese/esp/blob/master/reports/LicenseManager.html).

Some statistics about the assets:

| statistic               | value |
|-------------------------|-------|
| assets to protect       | 43    |
| code regions to protect | 35    |
| variables to protect    | 8     |
| SLOC to protect         | 1602  |

Some statistics about the attack paths:

| statistic                                               | value |
|---------------------------------------------------------|-------|
| attack paths                                            | 94    |
| attack paths that can be mitigated with high efficacy   | 65    |
| attack paths that can be mitigated with medium efficacy | 29    |
| attack paths that can be mitigated with low efficacy    | 0     |
| attack paths that cannot be mitigated                   | 0     |

Some statistics about the level 1 golden solution:

| protection                                                 | protected assets | protected SLOC |
|------------------------------------------------------------|------------------|----------------|
| anti-debugging                                             | 21               | 487            |
| binary obfuscation - branch functions (high overhead)      | 2                | 49             |
| binary obfuscation - branch functions (low overhead)       | 1                | 75             |
| binary obfuscation - function flattening (high overhead)   | 2                | 40             |
| binary obfuscation - function flattening (low overhead)    | 1                | 11             |
| binary obfuscation - function flattening (medium overhead) | 1                | 42             |
| binary obfuscation - opaque predicates (high overhead)     | 3                | 69             |
| binary obfuscation - opaque predicates (medium overhead)   | 1                | 10             |
| binary obfuscation - opaque predicates (low overhead)      | 1                | 25             |
| soft VM                                                    | 21               | 598            |
| white box cryptography                                     | 4                | 5              |

Some statistics about the level 2 golden solution:

| protection                                                 | protected assets | protected SLOC |
|------------------------------------------------------------|------------------|----------------|
| anti-debugging                                             | 58               | 966            |
| binary obfuscation - branch functions (high overhead)      | 2                | 12             |
| binary obfuscation - branch functions (low overhead)       | 2                | 76             |
| binary obfuscation - function flattening (high overhead)   | 2                | 40             |
| binary obfuscation - function flattening (low overhead)    | 11               | 21             |
| binary obfuscation - function flattening (medium overhead) | 1                | 42             |
| binary obfuscation - opaque predicates (high overhead)     | 3                | 69             |
| binary obfuscation - opaque predicates (medium overhead)   | 1                | 10             |
| binary obfuscation - opaque predicates (low overhead)      | 3                | 54             |
| soft VM                                                    | 64               | 1178           |
| white box cryptography                                     | 4                | 5              |

The SafeNet Inc. experts validated our results and reported that:

- the tiger team's report only included a set of attack steps, while the ADSS also reported the full attack paths
- the level 1 and 2 solution were declared as free from inconsistencies, not unrealistic, however, there was not a
  precise commitment to declare them as optimal

### OTP use case

This is a report of a one time password application for Gemalto N. V., now Thales Group (https://www.thalesgroup.com/).
You can read it by clicking
[here](https://htmlpreview.github.io/?https://github.com/daniele-canavese/esp/blob/master/reports/OTP.html).

Some statistics about the assets:

| statistic               | value |
|-------------------------|-------|
| assets to protect       | 22    |
| code regions to protect | 21    |
| variables to protect    | 1     |
| SLOC to protect         | 972   |

Some statistics about the attack paths:

| statistic                                               | value |
|---------------------------------------------------------|-------|
| attack paths                                            | 44    |
| attack paths that can be mitigated with high efficacy   | 32    |
| attack paths that can be mitigated with medium efficacy | 12    |
| attack paths that can be mitigated with low efficacy    | 0     |
| attack paths that cannot be mitigated                   | 0     |

Some statistics about the level 1 golden solution:

| protection                                              | protected assets | protected SLOC |
|---------------------------------------------------------|------------------|----------------|
| anti-debugging                                          | 4                | 36             |
| binary obfuscation - function flattening (low overhead) | 7                | 569            |
| code mobility                                           | 3                | 81             |
| static remote attestation (high frequency)              | 9                | 159            |

Some statistics about the level 2 golden solution:

| protection                                              | protected assets | protected SLOC |
|---------------------------------------------------------|------------------|----------------|
| anti-debugging                                          | 23               | 158            |
| binary obfuscation - branch functions (low overhead)    | 7                | 11             |
| binary obfuscation - function flattening (low overhead) | 12               | 578            |
| binary obfuscation - opaque predicates (low overhead)   | 7                | 11             |
| code mMobility                                          | 6                | 162            |
| static remote attestation (high frequency)              | 16               | 314            |

The Gemalto N. V. experts validated our results and reported that:

- the level 1 protections included several remote attestation protections and it was judged as appropriate;
- the level 1 protections included several code mobility protections and it was rated as "very meaningful";
- the level 1 solution was rated balanced and realistic;
- the ADSS was able to identify the attack ported by their tiger team against the master key and proposed valid
  suggestions on how to counter the attack;
- the experts did not object on the correctness and validity of the results, however, they were not able to express
  judgments on the level 1 and 2 solutions' optimality.
